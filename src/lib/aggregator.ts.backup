import { cache, CACHE_NAMESPACES, buildCacheKey, type CacheStats } from './cache';
import { 
  convertMicroUnits, 
  convertToUSD, 
  normalizeTimestamp,
  validateTransaction,
} from './normalization';
import { simpleBatchProcessor, type BatchResult } from './simple-batch';
import { createAptosClient } from './aptos-client';

// ============================================================================
// INTERFACES AND TYPES
// ============================================================================

export interface TimeRange {
  startDate: Date;
  endDate: Date;
}

export interface CoinEvent {
  type: 'deposit' | 'withdraw';
  amount: string;
  tokenType: string;
  timestamp: Date;
  transactionHash: string;
  sender: string;
  recipient: string;
  metadata?: Record<string, unknown>;
}

export interface AptosTransaction {
  version: string;
  hash: string;
  timestamp: Date;
  sender: string;
  receiver?: string;
  amount?: string;
  tokenType?: string;
  status: 'success' | 'failure';
  gasUsed: string;
  gasPrice: string;
  function: string;
  events: unknown[];
}

export interface WalletActivity {
  walletAddress: string;
  tokenType: string;
  dateRange: TimeRange;
  deposits: CoinEvent[];
  withdrawals: CoinEvent[];
  transactions: AptosTransaction[];
  netFlow: number;
  totalVolume: number;
  totalVolumeUSD: number;
  transactionCount: number;
  gasMetrics: GasMetrics;
  tradingStats: TradingStats;
  rebateAmount: number;
  lastUpdated: Date;
}

export interface GasMetrics {
  totalGasUsed: number;
  averageGasPerTx: number;
  totalGasCost: number;
  gasEfficiency: number;
  costSavingsVsEthereum: number;
}

export interface TradingStats {
  totalTrades: number;
  averageTradeSize: number;
  largestTrade: number;
  smallestTrade: number;
  tradeFrequency: number;
  volumeDistribution: Record<string, number>;
}

export interface AggregationResult {
  wallets: WalletActivity[];
  summary: {
    totalWallets: number;
    totalVolume: number;
    totalVolumeUSD: number;
    totalTransactions: number;
    totalGasUsed: number;
    totalRebates: number;
    averageNetFlow: number;
  };
  metadata: {
    processingTime: number;
    cacheHitRate: number;
    lastUpdated: Date;
  };
}

// ============================================================================
// WALLET ANALYZER CLASS
// ============================================================================

export class WalletAnalyzer {
  private aptosClient = createAptosClient();
  private cache = cache;

  constructor() {
    // Simple batch processor is ready to use
    console.log('WalletAnalyzer initialized with simple batch processor');

  // ============================================================================
  async analyzeWalletActivity(
    address: string,
    tokenType: string,
    dateRange: TimeRange
  ): Promise<WalletActivity> {
    const cacheKey = buildCacheKey(
      CACHE_NAMESPACES.WALLET_ACTIVITY,
      `${address}:${tokenType}:${dateRange.startDate.getTime()}:${dateRange.endDate.getTime()}`
    );

    // Try to get from cache first
    const cached = await this.cache.get<WalletActivity>(cacheKey);
    if (cached) {
      console.log(`Cache hit for wallet analysis: ${address}`);
      return cached;
    }

    console.log(`Analyzing wallet activity: ${address} for ${tokenType}`);

    try {
      // Fetch data from Aptos blockchain
      const [deposits, withdrawals, transactions] = await Promise.all([
        this.fetchDepositEvents(address, tokenType, dateRange),
        this.fetchWithdrawEvents(address, tokenType, dateRange),
        this.fetchTransactions(address, dateRange),
      ]);

      // Calculate metrics
      const netFlow = this.calculateNetFlow(deposits, withdrawals);
      const gasMetrics = this.computeGasMetrics(transactions);
      const tradingStats = this.generateTradingStats([...deposits, ...withdrawals]);
      
      // Calculate total volume and USD conversion
      const totalVolume = this.calculateTotalVolume(deposits, withdrawals);
      const totalVolumeUSD = await this.calculateTotalVolumeUSD(deposits, withdrawals);
      
      // Calculate rebate (0.01% of volume)
      const rebateAmount = totalVolume * 0.0001;

      const walletActivity: WalletActivity = {
        walletAddress: address,
        tokenType,
        dateRange,
        deposits,
        withdrawals,
        transactions,
        netFlow,
        totalVolume,
        totalVolumeUSD,
        transactionCount: transactions.length,
        gasMetrics,
        tradingStats,
        rebateAmount,
        lastUpdated: new Date(),
      };

      // Cache the result
      await this.cache.set(cacheKey, walletActivity, 15 * 60 * 1000); // 15 minutes

      return walletActivity;
    } catch (error) {
      console.error(`Failed to analyze wallet activity for ${address}:`, error);
      throw error;
    }
  }

  async analyzeMultipleWallets(
    addresses: string[],
    tokenTypes: string[],
    dateRange: TimeRange
  ): Promise<AggregationResult> {
    const startTime = Date.now();
    
    try {
      // Add batch processing job
        'wallet_analysis',
        { addresses, tokenTypes, dateRange },
        'high'
      );

      console.log(`Added batch wallet analysis job: ${jobId}`);

      // Process wallets in parallel with batching
      const walletPromises = addresses.map(address =>
        Promise.all(
          tokenTypes.map(tokenType =>
            this.analyzeWalletActivity(address, tokenType, dateRange)
          )
        )
      );

      const walletResults = await Promise.all(walletPromises);
      const wallets = walletResults.flat();

      // Calculate summary metrics
      const summary = this.calculateSummaryMetrics(wallets);

      // Get cache stats
      const cacheStats = this.cache.getStats();

      const result: AggregationResult = {
        wallets,
        summary,
        metadata: {
          processingTime: Date.now() - startTime,
          cacheHitRate: cacheStats.hitRate,
          lastUpdated: new Date(),
        },
      };

      return result;
    } catch (error) {
      console.error('Failed to analyze multiple wallets:', error);
      throw error;
    }
  }

  // ============================================================================
  // METRICS CALCULATION METHODS
  // ============================================================================

  calculateNetFlow(deposits: CoinEvent[], withdrawals: CoinEvent[]): number {
    try {
      const totalDeposits = deposits.reduce((sum, event) => {
        const amount = convertMicroUnits(event.amount, event.tokenType);
        return sum + amount;
      }, 0);

      const totalWithdrawals = withdrawals.reduce((sum, event) => {
        const amount = convertMicroUnits(event.amount, event.tokenType);
        return sum + amount;
      }, 0);

      return totalDeposits - totalWithdrawals;
    } catch (error) {
      console.error('Failed to calculate net flow:', error);
      return 0;
    }
  }

  computeGasMetrics(transactions: AptosTransaction[]): GasMetrics {
    try {
      const validTransactions = transactions.filter(tx => 
        tx.status === 'success' && validateTransaction(tx)
      );

      if (validTransactions.length === 0) {
        return {
          totalGasUsed: 0,
          averageGasPerTx: 0,
          totalGasCost: 0,
          gasEfficiency: 0,
          costSavingsVsEthereum: 0,
        };
      }

      const totalGasUsed = validTransactions.reduce((sum, tx) => {
        return sum + parseInt(tx.gasUsed);
      }, 0);

      const averageGasPerTx = totalGasUsed / validTransactions.length;
      
      // Calculate gas cost in APT (assuming gas price is in octas)
      const totalGasCost = validTransactions.reduce((sum, tx) => {
        const gasUsed = parseInt(tx.gasUsed);
        const gasPrice = parseInt(tx.gasPrice);
        const cost = (gasUsed * gasPrice) / 100000000; // Convert from octas
        return sum + cost;
      }, 0);

      // Gas efficiency (lower is better)
      const gasEfficiency = averageGasPerTx / 1000; // Normalize to 1000 gas baseline

      // Cost savings vs Ethereum (assuming 21000 gas per tx and $50 gas price)
      const ethereumGasPerTx = 21000;
      const ethereumGasPrice = 50; // USD
      const ethereumCostPerTx = (ethereumGasPerTx * ethereumGasPrice) / 1000000000; // Convert to USD
      const aptosCostPerTx = totalGasCost / validTransactions.length;
      const costSavingsVsEthereum = ethereumCostPerTx - aptosCostPerTx;

      return {
        totalGasUsed,
        averageGasPerTx,
        totalGasCost,
        gasEfficiency,
        costSavingsVsEthereum,
      };
    } catch (error) {
      console.error('Failed to compute gas metrics:', error);
      return {
        totalGasUsed: 0,
        averageGasPerTx: 0,
        totalGasCost: 0,
        gasEfficiency: 0,
        costSavingsVsEthereum: 0,
      };
    }
  }

  generateTradingStats(events: CoinEvent[]): TradingStats {
    try {
      if (events.length === 0) {
        return {
          totalTrades: 0,
          averageTradeSize: 0,
          largestTrade: 0,
          smallestTrade: 0,
          tradeFrequency: 0,
          volumeDistribution: {},
        };
      }

      // Convert amounts to display units
      const tradeSizes = events.map(event => 
        convertMicroUnits(event.amount, event.tokenType)
      );

      const totalTrades = events.length;
      const totalVolume = tradeSizes.reduce((sum, size) => sum + size, 0);
      const averageTradeSize = totalVolume / totalTrades;
      const largestTrade = Math.max(...tradeSizes);
      const smallestTrade = Math.min(...tradeSizes);

      // Calculate trade frequency (trades per day)
      const dateRange = this.calculateDateRange(events);
      const daysDiff = (dateRange.endDate.getTime() - dateRange.startDate.getTime()) / (1000 * 60 * 60 * 24);
      const tradeFrequency = daysDiff > 0 ? totalTrades / daysDiff : 0;

      // Volume distribution by day
      const volumeDistribution = this.calculateVolumeDistribution(events);

      return {
        totalTrades,
        averageTradeSize,
        largestTrade,
        smallestTrade,
        tradeFrequency,
        volumeDistribution,
      };
    } catch (error) {
      console.error('Failed to generate trading stats:', error);
      return {
        totalTrades: 0,
        averageTradeSize: 0,
        largestTrade: 0,
        smallestTrade: 0,
        tradeFrequency: 0,
        volumeDistribution: {},
      };
    }
  }

  // ============================================================================
  // VOLUME CALCULATION METHODS
  // ============================================================================

  calculateTotalVolume(deposits: CoinEvent[], withdrawals: CoinEvent[]): number {
    try {
      const allEvents = [...deposits, ...withdrawals];
      
      return allEvents.reduce((sum, event) => {
        const amount = convertMicroUnits(event.amount, event.tokenType);
        return sum + amount;
      }, 0);
    } catch (error) {
      console.error('Failed to calculate total volume:', error);
      return 0;
    }
  }

  async calculateTotalVolumeUSD(deposits: CoinEvent[], withdrawals: CoinEvent[]): Promise<number> {
    try {
      const allEvents = [...deposits, ...withdrawals];
      
      if (allEvents.length === 0) return 0;

      const usdAmounts = await Promise.all(
        allEvents.map(async (event) => {
          const amount = convertMicroUnits(event.amount, event.tokenType);
          return await convertToUSD(amount, event.tokenType);
        })
      );

      return usdAmounts.reduce((sum, amount) => sum + amount, 0);
    } catch (error) {
      console.error('Failed to calculate total volume in USD:', error);
      return 0;
    }
  }

  // ============================================================================
  // DATA FETCHING METHODS
  // ============================================================================

  private async fetchDepositEvents(
    address: string,
    tokenType: string,
    dateRange: TimeRange
  ): Promise<CoinEvent[]> {
    try {
      const events = await this.aptosClient.getDepositEvents(
        address,
        tokenType,
        1000 // Large limit to get all events
      );

      // Filter by date range and transform to CoinEvent format
      return events
        .filter(event => {
          const eventDate = normalizeTimestamp(event.timestamp);
          return eventDate >= dateRange.startDate && eventDate <= dateRange.endDate;
        })
        .map(event => ({
          type: 'deposit' as const,
          amount: event.data.amount,
          tokenType: event.data.tokenType,
          timestamp: normalizeTimestamp(event.timestamp),
          transactionHash: event.sequenceNumber, // Using sequence number as proxy for hash
          sender: event.data.sender,
          recipient: event.data.recipient,
        }));
    } catch (error) {
      console.error(`Failed to fetch deposit events for ${address}:`, error);
      return [];
    }
  }

  private async fetchWithdrawEvents(
    address: string,
    tokenType: string,
    dateRange: TimeRange
  ): Promise<CoinEvent[]> {
    try {
      const events = await this.aptosClient.getWithdrawEvents(
        address,
        tokenType,
        1000 // Large limit to get all events
      );

      // Filter by date range and transform to CoinEvent format
      return events
        .filter(event => {
          const eventDate = normalizeTimestamp(event.timestamp);
          return eventDate >= dateRange.startDate && eventDate <= dateRange.endDate;
        })
        .map(event => ({
          type: 'withdraw' as const,
          amount: event.data.amount,
          tokenType: event.data.tokenType,
          timestamp: normalizeTimestamp(event.timestamp),
          transactionHash: event.sequenceNumber, // Using sequence number as proxy for hash
          sender: event.data.sender,
          recipient: event.data.recipient,
        }));
    } catch (error) {
      console.error(`Failed to fetch withdraw events for ${address}:`, error);
      return [];
    }
  }

  private async fetchTransactions(
    address: string,
    dateRange: TimeRange
  ): Promise<AptosTransaction[]> {
    try {
      // Get transaction count first
      const txCount = await this.aptosClient.getTransactionCount(
        address,
        dateRange.startDate,
        dateRange.endDate
      );

      if (txCount === 0) return [];

      // For now, return mock transaction data
      // In production, you'd fetch actual transaction details
      const mockTransactions: AptosTransaction[] = Array.from({ length: Math.min(txCount, 100) }, (_, i) => ({
        version: `v${i}`,
        hash: `0x${i.toString(16).padStart(64, '0')}`,
        timestamp: new Date(dateRange.startDate.getTime() + (i * 24 * 60 * 60 * 1000)),
        sender: address,
        receiver: `0x${(i + 1).toString(16).padStart(64, '0')}`,
        amount: (Math.random() * 1000).toString(),
        tokenType: '0x1::aptos_coin::AptosCoin',
        status: 'success' as const,
        gasUsed: (1000 + Math.random() * 2000).toString(),
        gasPrice: (100 + Math.random() * 200).toString(),
        function: 'transfer',
        events: [],
      }));

      return mockTransactions;
    } catch (error) {
      console.error(`Failed to fetch transactions for ${address}:`, error);
      return [];
    }
  }

  // ============================================================================
  // UTILITY METHODS
  // ============================================================================

  private calculateDateRange(events: CoinEvent[]): TimeRange {
    if (events.length === 0) {
      const now = new Date();
      return {
        startDate: new Date(now.getTime() - 24 * 60 * 60 * 1000), // 1 day ago
        endDate: now,
      };
    }

    const timestamps = events.map(event => event.timestamp.getTime());
    const startTime = Math.min(...timestamps);
    const endTime = Math.max(...timestamps);

    return {
      startDate: new Date(startTime),
      endDate: new Date(endTime),
    };
  }

  private calculateVolumeDistribution(events: CoinEvent[]): Record<string, number> {
    const distribution: Record<string, number> = {};

    events.forEach(event => {
      const dateKey = event.timestamp.toISOString().split('T')[0];
      const amount = convertMicroUnits(event.amount, event.tokenType);
      
      distribution[dateKey] = (distribution[dateKey] || 0) + amount;
    });

    return distribution;
  }

  private calculateSummaryMetrics(wallets: WalletActivity[]): AggregationResult['summary'] {
    try {
      const totalWallets = wallets.length;
      const totalVolume = wallets.reduce((sum, wallet) => sum + wallet.totalVolume, 0);
      const totalVolumeUSD = wallets.reduce((sum, wallet) => sum + wallet.totalVolumeUSD, 0);
      const totalTransactions = wallets.reduce((sum, wallet) => sum + wallet.transactionCount, 0);
      const totalGasUsed = wallets.reduce((sum, wallet) => sum + wallet.gasMetrics.totalGasUsed, 0);
      const totalRebates = wallets.reduce((sum, wallet) => sum + wallet.rebateAmount, 0);
      const averageNetFlow = wallets.reduce((sum, wallet) => sum + wallet.netFlow, 0) / totalWallets;

      return {
        totalWallets,
        totalVolume,
        totalVolumeUSD,
        totalTransactions,
        totalGasUsed,
        totalRebates,
        averageNetFlow,
      };
    } catch (error) {
      console.error('Failed to calculate summary metrics:', error);
      return {
        totalWallets: 0,
        totalVolume: 0,
        totalVolumeUSD: 0,
        totalTransactions: 0,
        totalGasUsed: 0,
        totalRebates: 0,
        averageNetFlow: 0,
      };
    }
  }

  // ============================================================================
  // CACHE MANAGEMENT
  // ============================================================================

  async invalidateWalletCache(address: string): Promise<void> {
    try {
      const pattern = `${CACHE_NAMESPACES.WALLET_ACTIVITY}:${address}:*`;
      await this.cache.deletePattern(pattern);
      console.log(`Invalidated cache for wallet: ${address}`);
    } catch (error) {
      console.error(`Failed to invalidate cache for wallet ${address}:`, error);
    }
  }

  async warmWalletCache(addresses: string[], tokenTypes: string[]): Promise<void> {
    try {
      const now = new Date();
      const dateRange: TimeRange = {
        startDate: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000), // 30 days ago
        endDate: now,
      };

      // Add cache warming jobs
      for (const address of addresses) {
        for (const tokenType of tokenTypes) {
            'wallet_analysis',
            { address, tokenType, dateRange },
            'low'
          );
        }
      }

      console.log(`Added ${addresses.length * tokenTypes.length} cache warming jobs`);
    } catch (error) {
      console.error('Failed to warm wallet cache:', error);
    }
  }

  // ============================================================================
  // PERFORMANCE MONITORING
  // ============================================================================

  async getPerformanceMetrics(): Promise<{
    cacheStats: CacheStats;
    batchProcessorMetrics: { total: number; successful: number; failed: number; averageExecutionTime: number; totalExecutionTime: number };
    walletAnalysisCount: number;
  }> {
    try {
      const cacheStats = this.cache.getStats();
      
      // Count wallet analysis cache entries
      const walletKeys = await this.cache.getKeys(`${CACHE_NAMESPACES.WALLET_ACTIVITY}:*`);
      const walletAnalysisCount = walletKeys.length;

      return {
        cacheStats,
        batchProcessorMetrics: { total: 0, successful: 0, failed: 0, averageExecutionTime: 0, totalExecutionTime: 0 },
        walletAnalysisCount,
      };
    } catch (error) {
      console.error('Failed to get performance metrics:', error);
      return {
        cacheStats: { hits: 0, misses: 0, keys: 0, memoryUsage: 0, hitRate: 0 },
        batchProcessorMetrics: { total: 0, successful: 0, failed: 0, averageExecutionTime: 0, totalExecutionTime: 0 },
        walletAnalysisCount: 0,
      };
    }
  }
}

// ============================================================================
// DEFAULT INSTANCE
// ============================================================================

export const walletAnalyzer = new WalletAnalyzer();
